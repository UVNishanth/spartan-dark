"use strict";

const { Block, Blockchain, utils } = require("spartan-gold");

const SpartanDarkUtils = require("./spartan-dark-utils");

const fs = require("fs");
const snarkjs = require("snarkjs");

//HIGHLIGHTS: added cmLedger and snLedger
class SpartanDarkBlock extends Block {
  constructor(prevBlock) {
    super();

    this.prevBlockHash = prevBlock ? prevBlock.hashVal() : null;
    this.chainLength = prevBlock ? prevBlock.chainLength + 1 : 0;
    //this.target = target;

    //DESIGNDEC: sn is a Buffer. Converting it to String before storing in snLedger coz then searching becomes faster
    this.snLedger = prevBlock ? prevBlock.snLedger : [];

    // TODO: using list for storing commits for now. change to merkle tree later
    //DESIGNDEC: cm is a Buffer. Converting it to String before storing in cmLedger coz then searching becomes faster
    //BETTERCODE: convert snLedger and cmLedger to sets rather than lists for faster search
    this.cmLedger = prevBlock ? prevBlock.cmLedger : [];
    // this.cmLedger.forEach((x) => {
    //   console.log(x);
    // });
  }

  addTransaction(tx) {
    if (tx instanceof Blockchain.cfg.mintTransactionClass) {
      //console.log("Current block props: ");
      // for (let props in this) {
      //   console.log(props);
      // }
      //console.log("cmLedger is: ");
      //console.log(this.cmLedger);

      //HACK: updating cmLedger by first checking if it already exists. hack due to duplication.
      // needs fix. try to use single miner. rewrite rerun in Block. in rerun the transactions
      // get added again by calling addTransactions. so that might be triggering the duplication.
      //if(!this.cmLedger.includes(Buffer(tx.cm))){
      // if (
      //   !SpartanDarkUtils.bufferExistsInList(this.cmLedger, Buffer.from(tx.cm))
      // ) {
      //   this.cmLedger.push(Buffer.from(tx.cm));
      // }
      //let cmHash = SpartanDarkUtils.hash(Buffer.from(tx.cm));
      let txCm = Buffer.from(tx.cm).toString('base64');
      if (!this.cmLedger.includes(txCm)) {
        this.cmLedger.push(txCm);
      }
      this.transactions.set(tx.id, tx);
      return;
    }
    if (tx instanceof Blockchain.cfg.pourTransactionClass) {
      //console.log("Current block props: ");
      // for (let props in this) {
      //   console.log(props);
      // }
      //Add SpartanDarks generated by Pour into the cmLedger list
      // if (
      //   !SpartanDarkUtils.bufferExistsInList(
      //     this.cmLedger,
      //     Buffer.from(tx.cm1New)
      //   )
      // ) {
      //   this.cmLedger.push(Buffer.from(tx.cm1New));
      // }
      // if (
      //   !SpartanDarkUtils.bufferExistsInList(
      //     this.cmLedger,
      //     Buffer.from(tx.cm2New)
      //   )
      // ) {
      //   this.cmLedger.push(Buffer.from(tx.cm2New));
      // }

      let txCm1New = Buffer.from(tx.cm1New).toString("base64");
      if (!this.cmLedger.includes(txCm1New)) {
        this.cmLedger.push(txCm1New);
      }

      let txCm2New = Buffer.from(tx.cm2New).toString("base64");
      if (!this.cmLedger.includes(txCm2New)) {
        this.cmLedger.push(txCm2New);
      }

      // if (
      //   !SpartanDarkUtils.bufferExistsInList(this.snLedger, Buffer.from(tx.sn))
      // ) {
      //   this.snLedger.push(Buffer.from(tx.sn));
      //   console.log("sn of spent coin added to sn ledger");
      // }
      let txSn = Buffer.from(tx.sn).toString("base64");
      if (!this.snLedger.includes(txSn)) {
        this.snLedger.push(txSn);
        console.log("sn of spent coin added to sn ledger");
      }

      //DESIGNDEC: need not delete cmOld from cmLedger as it's a ledger of all cms accounted for. We gonna anyway check snLedger for double spending. And anyway we don't have cmOld information in pour transaction as that information is hidden so that it cannot be tracked back

      this.transactions.set(tx.id, tx);
      // console.log("cmLedger after pour acceptance is: ");
      // console.log(this.cmLedger);
      //process.exit(0);
      return;
    }

    throw new Error("Transaction not of expected type");
  }

  //TODO: currently only handles TranMint. Handle TranPour as well
  /**
   * Verifies a transaction.
   *
   * @param {TranMint | TranPour} tx - The transaction to verify.
   * @returns {Boolean} - True if the transaction was valid, false otherwise.
   */
  async verifyTransaction(tx) {
    if (tx instanceof Blockchain.cfg.mintTransactionClass) {
      let hashv = Buffer.from(tx.hashv);
      let k = Buffer.from(tx.k);
      let s = Buffer.from(tx.s);
      //let stringS = tx.s.toString();
      let cm = Buffer.from(tx.cm);

      let cm0 = SpartanDarkUtils.comm(hashv, k, s);
      if (!cm.equals(cm0)) {
        console.log(
          "Commitment is incorrect. should be " + cm + " instead got " + cm0
        );
        return false;
      }
      console.log("Commitment is correct");
      return true;
    } else if (tx instanceof Blockchain.cfg.pourTransactionClass) {
      //SpartanDarkUtils.printObjectProperties(tx);
      if (this.snLedger.includes(Buffer.from(tx.sn).toString("base64"))) {
        console.log(
          "Sn already present in Ledger. Spender trying to double spend!!"
        );
        return false;
      }
      let vKey = JSON.parse(fs.readFileSync("verification_key.json"));
      let res = await snarkjs.groth16.verify(
        vKey,
        tx.proof.publicSignals,
        tx.proof.proof
      );
      if (res !== true) {
        console.log("unverified proof");
        return false;
      }
      console.log("Pour transaction verified");
      return true;
    } else {
      throw new Error("Received transaction type unknown");
    }
  }

  toJSON() {
    let o = super.toJSON();
    o.cmLedger = this.cmLedger;
    o.snLedger = this.snLedger;
    return o;
  }
}

module.exports.SpartanDarkBlock = SpartanDarkBlock;
